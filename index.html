<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Hide and Seek</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
        }
        /* Prevents flashing of the button before WebXR availability is checked */
        #ar-button {
            display: none;
        }
        /* Make the container transparent during AR session to see the camera feed */
        #main-container.ar-mode {
            background-color: transparent;
        }
        /* Simple spinner for loading state */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- Main Container -->
    <div id="main-container" class="min-h-screen flex flex-col items-center justify-center p-4">
        
        <!-- UI Container -->
        <div id="ui-container" class="w-full max-w-md text-center">
            <h1 class="text-4xl font-bold mb-4">XR Hide & Seek</h1>
            <p id="instructions" class="text-lg text-gray-300 mb-8">
                Find a friend and a well-lit room to play!
            </p>

            <!-- AR Button -->
            <button id="ar-button" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-transform duration-200 transform hover:scale-105">
                Start AR
            </button>

            <!-- Status Messages -->
            <div id="status-message" class="mt-8 text-gray-400"></div>
            <div id="unsupported-message" class="hidden mt-8 p-4 bg-red-800/50 border border-red-700 rounded-lg">
                <h2 class="font-bold text-red-300">AR Not Supported</h2>
                <p class="text-red-400">Your browser does not support the WebXR API, or you need to enable it in your browser settings. Please use a compatible browser like Chrome on an AR-enabled Android device.</p>
            </div>
             <div id="stabilization-message" class="hidden mt-4 text-yellow-400">
                Move your device slowly to scan the area.
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Basic Three.js Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // --- Game State and Objects ---
        let xrSession = null;
        let xrRefSpace = null;
        let xrHitTestSource = null;
        
        let reticle; // The ring that shows where you can place objects
        let hiddenObject = null; // The object to hide
        let gameState = 'INITIAL'; // INITIAL, HIDING, SEEKING

        const mainContainer = document.getElementById('main-container');
        const arButton = document.getElementById('ar-button');
        const instructions = document.getElementById('instructions');
        const statusMessage = document.getElementById('status-message');
        const unsupportedMessage = document.getElementById('unsupported-message');
        const stabilizationMessage = document.getElementById('stabilization-message');

        // --- Check for WebXR Support ---
        async function checkXRSupport() {
            if (navigator.xr) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        arButton.style.display = 'block';
                        statusMessage.innerText = "Ready to start the AR session.";
                    } else {
                        unsupportedMessage.style.display = 'block';
                    }
                } catch (e) {
                    console.error("Error checking XR support:", e);
                    unsupportedMessage.style.display = 'block';
                }
            } else {
                unsupportedMessage.style.display = 'block';
            }
        }

        // --- Initialize the AR Session ---
        async function onARSessionStart() {
            try {
                // Append the renderer's canvas to the body
                document.body.appendChild(renderer.domElement);

                xrSession = await navigator.xr.requestSession('immersive-ar', {
                    requiredFeatures: ['hit-test', 'dom-overlay'],
                    domOverlay: { root: mainContainer }
                });

                // Add class to make the DOM overlay transparent
                mainContainer.classList.add('ar-mode');
                
                xrRefSpace = await xrSession.requestReferenceSpace('local');
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                // Add event listeners for session events
                xrSession.addEventListener('select', onSelect);
                xrSession.addEventListener('end', onARSessionEnd);

                // Hide UI elements that are not needed in AR
                arButton.style.display = 'none';
                statusMessage.style.display = 'none';
                
                // Set initial game state
                setGameState('HIDING');

                renderer.setAnimationLoop(onXRFrame);
                
            } catch (e) {
                console.error("Failed to start AR session:", e);
                unsupportedMessage.innerText = `Failed to start AR session: ${e.message}`;
                unsupportedMessage.style.display = 'block';
            }
        }
        
        // --- Handle AR Session End ---
        function onARSessionEnd() {
            // Remove the transparent background class
            mainContainer.classList.remove('ar-mode');

            // Show the initial UI again
            arButton.style.display = 'block';
            instructions.innerHTML = "Find a friend and a well-lit room to play!";
            statusMessage.style.display = 'block';

            // Clean up objects
            if (hiddenObject) hiddenObject.visible = false;
            if (reticle) reticle.visible = false;
            
            // Remove any dynamically added buttons
            const restartButton = instructions.querySelector('button');
            if (restartButton) restartButton.remove();

            // Stop the render loop
            renderer.setAnimationLoop(null);
            xrSession = null;
        }

        // --- The Main Render Loop ---
        function onXRFrame(time, frame) {
            if (!frame || !xrSession) return;

            const viewerPose = frame.getViewerPose(xrRefSpace);
            if (viewerPose) {
                // Update camera position and orientation
                const view = viewerPose.views[0];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Handle hit testing for object placement
                if (xrHitTestSource && gameState === 'HIDING') {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    if (hitTestResults.length > 0) {
                        stabilizationMessage.style.display = 'none';
                        const hit = hitTestResults[0];
                        const pose = hit.getPose(xrRefSpace);
                        reticle.visible = true;
                        reticle.matrix.fromArray(pose.transform.matrix);
                    } else {
                        stabilizationMessage.style.display = 'block';
                        reticle.visible = false;
                    }
                }
            }
            
            renderer.render(scene, camera);
        }

        // --- Game Logic ---
        function setGameState(newState) {
            gameState = newState;
            const restartButton = instructions.querySelector('button');
            if (restartButton) restartButton.remove();

            switch (gameState) {
                case 'HIDING':
                    instructions.innerText = "Player 1: Find a good spot and tap the screen to hide the object.";
                    if (!reticle) createReticle();
                    reticle.visible = true;
                    if(hiddenObject) hiddenObject.visible = false;
                    break;
                case 'SEEKING':
                    instructions.innerHTML = "Player 2: Object hidden! <br> Hand the device over and find the hidden object.";
                    if (reticle) reticle.visible = false;
                    if(hiddenObject) hiddenObject.visible = true;
                    
                    // Add a button to restart
                    const newRestartButton = document.createElement('button');
                    newRestartButton.innerText = 'Found It! (Play Again)';
                    newRestartButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg text-xl mt-4 transition-transform duration-200 transform hover:scale-105';
                    newRestartButton.onclick = () => {
                        setGameState('HIDING');
                    };
                    instructions.appendChild(document.createElement('br'));
                    instructions.appendChild(newRestartButton);
                    break;
            }
        }

        // --- Create 3D Objects ---
        function createReticle() {
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00aaff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        function createHiddenObject() {
            const geometry = new THREE.TorusGeometry(0.1, 0.04, 16, 100);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff4500, // OrangeRed
                metalness: 0.3,
                roughness: 0.2 
            });
            hiddenObject = new THREE.Mesh(geometry, material);
            hiddenObject.visible = false;
            scene.add(hiddenObject);
        }

        // --- Handle User Input ---
        function onSelect() {
            if (gameState === 'HIDING' && reticle.visible) {
                if (!hiddenObject) createHiddenObject();
                
                // Position the hidden object at the reticle's location
                hiddenObject.position.setFromMatrixPosition(reticle.matrix);
                hiddenObject.quaternion.setFromRotationMatrix(reticle.matrix);
                
                setGameState('SEEKING');
            }
        }

        // --- Event Listeners ---
        arButton.addEventListener('click', onARSessionStart);
        
        document.addEventListener('DOMContentLoaded', checkXRSupport);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
