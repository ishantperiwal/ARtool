<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR AR Pin Finder</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
        }
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <script type="module">
        import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js';
        import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/webxr/ARButton.js';

        let container;
        let camera, scene, renderer;
        let hitTestSource = null;
        let hitTestSourceRequested = false;
        let placed = false;
        let pinMatrix = new THREE.Matrix4();
        let hud;
        let leftArrowHelper, rightArrowHelper;

        const geometry = new THREE.CylinderGeometry(0.05, 0.05, 0.2, 32).translate(0, 0.1, 0);

        function init() {
            container = document.createElement('div');
            document.body.appendChild(container);

            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 3);
            light.position.set(0.5, 1, 0.25);
            scene.add(light);

            hud = new THREE.Group();
            scene.add(hud);

            // Left arrow (red, points left to indicate turn left)
            const leftDir = new THREE.Vector3(-1, 0, 0);
            leftArrowHelper = new THREE.ArrowHelper(leftDir, new THREE.Vector3(), 0.2, 0xff0000);
            leftArrowHelper.position.set(0, -0.2, -0.5);
            leftArrowHelper.visible = false;
            hud.add(leftArrowHelper);

            // Right arrow (green, points right to indicate turn right)
            const rightDir = new THREE.Vector3(1, 0, 0);
            rightArrowHelper = new THREE.ArrowHelper(rightDir, new THREE.Vector3(), 0.2, 0x00ff00);
            rightArrowHelper.position.set(0, -0.2, -0.5);
            rightArrowHelper.visible = false;
            hud.add(rightArrowHelper);

            document.body.appendChild(ARButton.createButton(renderer, { requiredFeatures: ['hit-test'] }));

            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            renderer.setAnimationLoop(render);
        }

        function render(timestamp, frame) {
            if (frame) {
                const referenceSpace = renderer.xr.getReferenceSpace();
                const session = renderer.xr.getSession();

                if (!hitTestSourceRequested) {
                    // Generate random yaw and fixed pitch down for ground hit
                    const pitch = -Math.PI / 6; // ~30 degrees down
                    const yaw = Math.random() * Math.PI * 2;
                    const quat = new THREE.Quaternion().setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
                    const offsetRay = new XRRigidTransform({ x: 0, y: 0, z: 0, w: 1 }, { x: quat.x, y: quat.y, z: quat.z, w: quat.w });

                    session.requestReferenceSpace('viewer').then((viewerSpace) => {
                        session.requestHitTestSource({ space: viewerSpace, offsetRay: offsetRay, entityTypes: ['plane'] }).then((source) => {
                            hitTestSource = source;
                        });
                    });

                    hitTestSourceRequested = true;
                }

                if (hitTestSource && !placed) {
                    const hitTestResults = frame.getHitTestResults(hitTestSource);
                    if (hitTestResults.length) {
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(referenceSpace);

                        const material = new THREE.MeshPhongMaterial({ color: 0xff0000 });
                        const pin = new THREE.Mesh(geometry, material);
                        pin.matrix.fromArray(hitPose.transform.matrix);
                        pin.matrixAutoUpdate = false;
                        scene.add(pin);

                        pinMatrix.copy(pin.matrix);
                        placed = true;
                        hitTestSource.cancel();
                        hitTestSource = null;
                    }
                }

                if (placed) {
                    const viewerPose = frame.getViewerPose(referenceSpace);
                    if (viewerPose) {
                        const viewTransform = viewerPose.views[0].transform;
                        const viewerMatrix = new THREE.Matrix4().fromArray(viewTransform.matrix);
                        const viewerPosition = new THREE.Vector3().setFromMatrixPosition(viewerMatrix);
                        const viewerQuaternion = new THREE.Quaternion().setFromRotationMatrix(viewerMatrix);

                        hud.position.copy(viewerPosition);
                        hud.quaternion.copy(viewerQuaternion);

                        const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(viewerQuaternion);
                        const forwardXZ = new THREE.Vector3(forward.x, 0, forward.z).normalize();

                        const pinPosition = new THREE.Vector3().setFromMatrixPosition(pinMatrix);
                        const toPin = pinPosition.clone().sub(viewerPosition);
                        const toPinXZ = new THREE.Vector3(toPin.x, 0, toPin.z).normalize();

                        const dot = forwardXZ.dot(toPinXZ);
                        const det = forwardXZ.x * toPinXZ.z - forwardXZ.z * toPinXZ.x;
                        const angle = Math.atan2(det, dot);

                        leftArrowHelper.visible = false;
                        rightArrowHelper.visible = false;

                        if (Math.abs(angle) > 0.1) {
                            if (angle > 0) {
                                rightArrowHelper.visible = true;
                            } else {
                                leftArrowHelper.visible = true;
                            }
                        }
                    }
                }
            }

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
