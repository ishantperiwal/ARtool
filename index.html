<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebXR Hide and Seek</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        /* This container holds the entire AR experience. It's hidden by default. */
        #ar-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            display: none; /* Hidden until AR session starts */
        }
        /* The 3D canvas needs to be positioned absolutely behind the UI overlay. */
        #ar-container canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }
        /* The UI that floats on top of the AR view. */
        #ar-overlay {
            position: relative; /* Changed from absolute to relative to stack correctly */
            z-index: 2; /* Ensures UI is on top of the canvas */
            padding: 1rem;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.6), rgba(0,0,0,0));
        }
    </style>
</head>
<body class="bg-gray-900 text-white">

    <!-- This is the UI shown before the AR session starts. -->
    <div id="initial-ui-container" class="min-h-screen w-full h-full flex flex-col items-center justify-center p-4">
        <h1 class="text-4xl font-bold mb-4">XR Hide & Seek</h1>
        <p class="text-lg text-gray-300 mb-8">
            Find a friend and a well-lit room to play!
        </p>
        <button id="ar-button" style="display: none;" class="bg-blue-600 hover:bg-blue-700 text-white font-bold py-3 px-6 rounded-lg text-xl transition-transform duration-200 transform hover:scale-105">
            Start AR
        </button>
        <div id="status-message" class="mt-8 text-gray-400"></div>
        <div id="unsupported-message" class="hidden mt-8 p-4 bg-red-800/50 border border-red-700 rounded-lg">
            <h2 class="font-bold text-red-300">AR Not Supported</h2>
            <p class="text-red-400">Your browser does not support the WebXR API. Please use a compatible browser.</p>
        </div>
    </div>

    <!-- This container will hold the canvas and the AR UI. -->
    <div id="ar-container">
        <div id="ar-overlay">
            <p id="instructions" class="text-xl text-white mb-4"></p>
            <div id="stabilization-message" class="hidden mt-4 text-yellow-400">
                Move your device slowly to scan the area.
            </div>
        </div>
    </div>

    <!-- Three.js Library -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script type="module">
        // --- Basic Three.js Scene Setup ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.xr.enabled = true;

        // --- Lighting ---
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 1);
        scene.add(directionalLight);

        // --- Game State and Objects ---
        let xrSession = null;
        let xrRefSpace = null;
        let xrHitTestSource = null;
        let reticle;
        let hiddenObject = null;
        let gameState = 'INITIAL';

        // --- UI Elements ---
        const initialUiContainer = document.getElementById('initial-ui-container');
        const arContainer = document.getElementById('ar-container');
        const arOverlay = document.getElementById('ar-overlay');
        const arButton = document.getElementById('ar-button');
        const instructions = document.getElementById('instructions');
        const statusMessage = document.getElementById('status-message');
        const unsupportedMessage = document.getElementById('unsupported-message');
        const stabilizationMessage = document.getElementById('stabilization-message');

        // --- Check for WebXR Support ---
        async function checkXRSupport() {
            if (navigator.xr) {
                try {
                    const supported = await navigator.xr.isSessionSupported('immersive-ar');
                    if (supported) {
                        arButton.style.display = 'block';
                        statusMessage.innerText = "Ready to start the AR session.";
                    } else {
                        unsupportedMessage.style.display = 'block';
                    }
                } catch (e) {
                    console.error("Error checking XR support:", e);
                    unsupportedMessage.style.display = 'block';
                }
            } else {
                unsupportedMessage.style.display = 'block';
            }
        }

        // --- Initialize the AR Session ---
        async function onARSessionStart() {
            try {
                xrSession = await navigator.xr.requestSession('immersive-ar', { requiredFeatures: ['hit-test'] });

                // CRITICAL: Make the body transparent to see the camera feed.
                document.body.style.backgroundColor = 'transparent';
                initialUiContainer.style.display = 'none';
                arContainer.style.display = 'block';
                
                // Add the renderer's canvas to the AR container.
                arContainer.appendChild(renderer.domElement);

                // Set up the XR reference spaces.
                xrRefSpace = await xrSession.requestReferenceSpace('local');
                const viewerSpace = await xrSession.requestReferenceSpace('viewer');
                xrHitTestSource = await xrSession.requestHitTestSource({ space: viewerSpace });

                xrSession.addEventListener('select', onSelect);
                xrSession.addEventListener('end', onARSessionEnd);
                
                setGameState('HIDING');
                renderer.setAnimationLoop(onXRFrame);
            } catch (e) {
                console.error("Failed to start AR session:", e);
                unsupportedMessage.innerText = `Failed to start AR session: ${e.message}`;
                unsupportedMessage.style.display = 'block';
            }
        }
        
        // --- Handle AR Session End ---
        function onARSessionEnd() {
            // CRITICAL: Restore the original UI state.
            document.body.style.backgroundColor = ''; // Reverts to CSS color
            initialUiContainer.style.display = 'flex';
            arContainer.style.display = 'none';
            stabilizationMessage.style.display = 'none';

            // Clean up objects and UI.
            if (hiddenObject) hiddenObject.visible = false;
            if (reticle) reticle.visible = false;
            const restartButton = arOverlay.querySelector('button');
            if (restartButton) restartButton.remove();

            // Stop the render loop and clean up the canvas.
            renderer.setAnimationLoop(null);
            if (renderer.domElement.parentElement) {
                renderer.domElement.parentElement.removeChild(renderer.domElement);
            }
            xrSession = null;
        }

        // --- The Main Render Loop ---
        function onXRFrame(time, frame) {
            if (!frame || !xrSession) return;

            const pose = frame.getViewerPose(xrRefSpace);
            if (pose) {
                // Update camera and render the scene.
                const view = pose.views[0];
                camera.matrix.fromArray(view.transform.matrix);
                camera.projectionMatrix.fromArray(view.projectionMatrix);
                camera.updateMatrixWorld(true);

                // Handle hit testing for placing the object.
                if (xrHitTestSource && gameState === 'HIDING') {
                    const hitTestResults = frame.getHitTestResults(xrHitTestSource);
                    if (hitTestResults.length > 0) {
                        stabilizationMessage.style.display = 'none';
                        const hit = hitTestResults[0];
                        const hitPose = hit.getPose(xrRefSpace);
                        if(reticle) {
                            reticle.visible = true;
                            reticle.matrix.fromArray(hitPose.transform.matrix);
                        }
                    } else {
                        stabilizationMessage.style.display = 'block';
                        if(reticle) reticle.visible = false;
                    }
                }
                
                renderer.render(scene, camera);
            }
        }

        // --- Game Logic ---
        function setGameState(newState) {
            gameState = newState;
            const restartButton = arOverlay.querySelector('button');
            if (restartButton) restartButton.remove();

            switch (gameState) {
                case 'HIDING':
                    instructions.innerText = "Player 1: Find a good spot and tap the screen to hide the object.";
                    if (!reticle) createReticle();
                    reticle.visible = true;
                    if(hiddenObject) hiddenObject.visible = false;
                    break;
                case 'SEEKING':
                    instructions.innerHTML = "Player 2: Object hidden! <br> Hand the device over and find the hidden object.";
                    if (reticle) reticle.visible = false;
                    if(hiddenObject) hiddenObject.visible = true;
                    
                    const newRestartButton = document.createElement('button');
                    newRestartButton.innerText = 'Found It! (Play Again)';
                    newRestartButton.className = 'bg-green-600 hover:bg-green-700 text-white font-bold py-2 px-4 rounded-lg text-lg mt-4 transition-transform duration-200 transform hover:scale-105';
                    newRestartButton.onclick = () => {
                        setGameState('HIDING');
                    };
                    arOverlay.appendChild(newRestartButton);
                    break;
            }
        }

        // --- Create 3D Objects ---
        function createReticle() {
            reticle = new THREE.Mesh(
                new THREE.RingGeometry(0.08, 0.1, 32).rotateX(-Math.PI / 2),
                new THREE.MeshBasicMaterial({ color: 0x00aaff })
            );
            reticle.matrixAutoUpdate = false;
            reticle.visible = false;
            scene.add(reticle);
        }

        function createHiddenObject() {
            const geometry = new THREE.TorusGeometry(0.1, 0.04, 16, 100);
            const material = new THREE.MeshStandardMaterial({ 
                color: 0xff4500, // OrangeRed
                metalness: 0.3,
                roughness: 0.2 
            });
            hiddenObject = new THREE.Mesh(geometry, material);
            hiddenObject.visible = false;
            scene.add(hiddenObject);
        }

        // --- Handle User Input ---
        function onSelect() {
            if (gameState === 'HIDING' && reticle && reticle.visible) {
                if (!hiddenObject) createHiddenObject();
                
                hiddenObject.position.setFromMatrixPosition(reticle.matrix);
                hiddenObject.quaternion.setFromRotationMatrix(reticle.matrix);
                
                setGameState('SEEKING');
            }
        }

        // --- Event Listeners ---
        arButton.addEventListener('click', onARSessionStart);
        document.addEventListener('DOMContentLoaded', checkXRSupport);
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>
</html>
